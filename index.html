<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Target Training App</title>
  <style>
    :root{
      color-scheme: dark;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      --bg:#0e141d;
      --panel:#141d2a;
      --panel-border:#1f2a3a;
      --text:#f2f6ff;
      --muted:#9aa8bf;
      --accent:#3ea8ff;
      --danger:#ef5f6b;
      --pane-width:380px;
    }
    *{box-sizing:border-box;}
    html, body{height:100%;}
    body{
      margin:0;
      height:100%;
      background:var(--bg);
      color:var(--text);
      font-family:"Inter","Segoe UI",system-ui,sans-serif;
      overflow:hidden;
    }
    h1{margin:0;font-size:24px;}
    h2{margin:0 0 12px;font-size:18px;color:var(--muted);}
    p{margin:0;}
    label{display:flex;flex-direction:column;gap:6px;font-size:13px;color:var(--muted);}
    input, select, button{font:inherit;}
    input[type=number], input[type=text], select{
      background:#101827;border:1px solid var(--panel-border);border-radius:10px;padding:8px 12px;
      color:var(--text);
    }
    input[type=color]{width:48px;height:38px;border:1px solid var(--panel-border);border-radius:10px;padding:2px;background:#101827;}
    input[type=checkbox]{margin-right:6px;accent-color:var(--accent);}
    button{border:0;border-radius:12px;padding:12px 20px;font-weight:600;cursor:pointer;transition:transform .15s ease,filter .15s ease,opacity .15s ease;}
    button.primary{background:var(--accent);color:#021126;}
    button.ghost{background:#1b2535;color:var(--text);}
    button.danger{background:var(--danger);color:#2a0d11;}
    button:disabled{opacity:0.6;cursor:not-allowed;}
    button:not(:disabled):active{transform:scale(0.97);}

    .app{display:flex;min-height:100vh;height:100vh;width:100%;overflow:hidden;position:relative;}
    .config-pane{
      width:min(var(--pane-width), 90vw);
      flex:0 0 min(var(--pane-width), 90vw);
      background:var(--panel);
      border-right:1px solid var(--panel-border);
      padding:24px 24px 32px;
      overflow-y:auto;
      transition:transform .3s ease,box-shadow .3s ease;
      transform:translateX(0);
      box-shadow:24px 0 48px rgba(0,0,0,0.35);
      position:relative;
      z-index:5;
      height:100vh;
    }
    body.menu-collapsed .config-pane{
      transform:translateX(calc(-1 * min(var(--pane-width), 90vw)));
      margin-right:calc(-1 * min(var(--pane-width), 90vw));
      box-shadow:none;
      pointer-events:none;
      overflow:hidden;
    }
    body.menu-collapsed .config-pane .config-scroll{opacity:0;}
    body:not(.menu-collapsed) .config-pane .config-scroll{opacity:1;transition:opacity .2s ease;}
    .config-scroll{display:grid;gap:18px;transition:opacity .2s ease;opacity:1;}
    .config-header p{margin-top:6px;color:var(--muted);font-size:14px;line-height:1.45;}
    .panel{background:rgba(16,24,39,0.72);border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:18px;box-shadow:0 12px 32px rgba(0,0,0,0.28);}
    .panel h2{color:var(--muted);}
    .grid{display:grid;gap:14px;}
    .grid.two{grid-template-columns:repeat(auto-fit,minmax(220px,1fr));}
    .actions{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-top:14px;}
    .preset-controls{display:flex;flex-direction:column;gap:12px;}
    .preset-actions{display:flex;gap:10px;flex-wrap:wrap;}
    .preset-controls select{width:100%;}
    .status-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px;margin-top:16px;}
    .status-card{background:#101827;border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:12px;display:grid;gap:4px;}
    .status-card span{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:0.04em;}
    .status-card strong{font-size:20px;font-variant-numeric:tabular-nums;}
    .toggles{display:flex;gap:14px;align-items:center;flex-wrap:wrap;}
    .inline{display:flex;gap:8px;align-items:center;}
    .inline .compact-number{width:82px;text-align:right;}
    .size-opts{display:flex;gap:12px;flex-wrap:wrap;}
    .size-opts label{max-width:160px;}
    .note{font-size:12px;color:var(--muted);margin-top:6px;}

    .board-area{flex:1;position:relative;background:#fff;color:#111;display:flex;height:100vh;overflow:hidden;}
    #targetBoard{flex:1;position:relative;background:#fff;height:100%;min-height:auto;overflow:hidden;}
    #targetBoard::after{content:"";position:absolute;inset:0;pointer-events:none;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.08);}
    .board-area::after{content:"";position:absolute;inset:0;pointer-events:none;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.05);}
    .corner-controls{position:absolute;top:20px;right:20px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;z-index:10;background:rgba(14,20,29,0.72);border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:10px 12px;backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);}
    .corner-controls button{padding:10px 16px;border-radius:10px;font-size:14px;}
    .corner-controls .ghost{background:rgba(27,37,53,0.65);}

    .target{position:absolute;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;line-height:1;pointer-events:none;user-select:none;transition:transform .3s ease,opacity .3s ease;box-shadow:0 10px 24px rgba(0,0,0,0.22);}
    .target.circle{border-radius:50%;}
    .target.square{border-radius:12px;}
    .target span{display:flex;align-items:center;justify-content:center;padding:0.2em 0.5em;border-radius:0.6em;background:rgba(0,0,0,0.25);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);min-width:1.4em;}
    #targetBoard.targets-hidden .target{opacity:0;}
    @media (max-width:720px){
      .corner-controls{top:12px;right:12px;gap:8px;}
      .corner-controls button{width:100%;}
    }
  </style>
</head>
<body class="menu-collapsed">
  <main class="app">
    <aside id="configPane" class="config-pane">
      <div class="config-scroll">
        <div class="panel config-header">
          <h1>Target Training App</h1>
          <p>Randomize the start cue, follow with a stop cue, and populate a configurable target board for visual drills.</p>
        </div>

        <section class="panel" id="presetPanel">
          <h2>Presets</h2>
          <div class="preset-controls">
            <select id="presetSelect" title="Load a preset"></select>
            <div class="preset-actions">
              <button id="savePreset" class="ghost" type="button">Save Preset</button>
              <button id="deletePreset" class="danger" type="button">Delete Preset</button>
            </div>
          </div>
          <p class="note">Presets and the last-used settings stay on this device.</p>
        </section>

        <section class="panel" id="timerPanel">
          <h2>Timing &amp; Beeps</h2>
          <div class="grid two">
            <label>Random start delay (s)
              <div class="inline">
                <input type="number" class="compact-number" id="delayMin" min="0" step="0.1" value="1.0" placeholder="Min" />
                <span style="color:var(--muted);">to</span>
                <input type="number" class="compact-number" id="delayMax" min="0" step="0.1" value="3.0" placeholder="Max" />
              </div>
            </label>
            <label>Work window after start (s)
              <input type="number" id="workDuration" min="0" step="0.1" value="5.0" />
            </label>
            <label>Start beep frequency (Hz)
              <input type="number" id="startFreq" min="200" max="4000" step="1" value="950" />
            </label>
            <label>Start beep length (s)
              <input type="number" id="startLen" min="0.05" max="1.0" step="0.01" value="0.20" />
            </label>
            <label>Stop beep frequency (Hz)
              <input type="number" id="stopFreq" min="200" max="4000" step="1" value="1200" />
            </label>
            <label>Stop beep length (s)
              <input type="number" id="stopLen" min="0.05" max="1.5" step="0.01" value="0.25" />
            </label>
          </div>
          <div class="actions">
            <button id="testStart" class="ghost">Test start beep</button>
            <button id="testStop" class="ghost">Test stop beep</button>
          </div>
          <p class="note">Press Space to toggle start/stop even when the menu is hidden.</p>
          <div class="status-grid">
            <div class="status-card">
              <span>Status</span>
              <strong id="status">Idle</strong>
            </div>
            <div class="status-card">
              <span>Start in</span>
              <strong id="countStart">—</strong>
            </div>
            <div class="status-card">
              <span>Stop in</span>
              <strong id="countStop">—</strong>
            </div>
            <div class="status-card">
              <span>Selected delay</span>
              <strong id="selectedDelay">—</strong>
            </div>
          </div>
        </section>

        <section class="panel" id="targetsPanel">
          <h2>Target board</h2>
          <div class="grid two">
            <label>Number of targets
              <input type="number" id="targetCount" min="0" max="60" step="1" value="8" />
            </label>
            <label>Shape
              <select id="targetShape">
                <option value="circle">Circle</option>
                <option value="square">Square</option>
              </select>
            </label>
            <label>Target color
              <input type="color" id="targetColor" value="#d62828" />
            </label>
            <label>Arrangement
              <select id="targetLayout">
                <option value="random">Random placement</option>
                <option value="grid">Grid layout</option>
              </select>
            </label>
          </div>
          <div class="toggles">
            <label class="inline" style="color:var(--muted); font-size:13px;">
              <input type="checkbox" id="targetNumbered" checked />
              Number targets
            </label>
            <label class="inline" style="color:var(--muted); font-size:13px;">
              <input type="checkbox" id="randomSizes" />
              Randomize size
            </label>
            <label class="inline" style="color:var(--muted); font-size:13px;">
              <input type="checkbox" id="hideTargets" />
              Hide until start beep
            </label>
          </div>
          <div class="size-opts" id="fixedSizeOptions">
            <label>Target size (px)
              <input type="number" id="targetSize" min="10" max="320" step="1" value="80" />
            </label>
          </div>
          <div class="size-opts" id="randomSizeOptions" hidden>
            <label>Min size (px)
              <input type="number" id="targetSizeMin" min="10" max="320" step="1" value="50" />
            </label>
            <label>Max size (px)
              <input type="number" id="targetSizeMax" min="10" max="360" step="1" value="120" />
            </label>
          </div>
          <p class="note">Targets repopulate when settings change. Use the layout toggle for a grid and optionally hide them until the run starts.</p>
        </section>
      </div>
    </aside>

    <section class="board-area" id="boardArea">
      <div class="corner-controls">
        <button id="startBtn" class="primary">Start</button>
        <button id="stopBtn" class="danger" disabled>Stop</button>
        <button id="toggleMenu" class="ghost" aria-expanded="false">Show settings</button>
      </div>
      <div id="targetBoard" class="board"></div>
    </section>
  </main>

  <script>
    (function(){
      'use strict';
      var $ = function(id){ return document.getElementById(id); };
      var els = {
        delayMin: $('delayMin'), delayMax: $('delayMax'), workDuration: $('workDuration'),
        startFreq: $('startFreq'), startLen: $('startLen'), stopFreq: $('stopFreq'), stopLen: $('stopLen'),
        startBtn: $('startBtn'), stopBtn: $('stopBtn'), testStart: $('testStart'), testStop: $('testStop'),
        status: $('status'), countStart: $('countStart'), countStop: $('countStop'), selectedDelay: $('selectedDelay'),
        targetCount: $('targetCount'), targetShape: $('targetShape'), targetColor: $('targetColor'),
        targetNumbered: $('targetNumbered'), randomSizes: $('randomSizes'), targetSize: $('targetSize'),
        targetSizeMin: $('targetSizeMin'), targetSizeMax: $('targetSizeMax'), targetBoard: $('targetBoard'),
        targetLayout: $('targetLayout'), hideTargets: $('hideTargets'),
        toggleMenu: $('toggleMenu'), configPane: $('configPane'),
        presetSelect: $('presetSelect'), savePreset: $('savePreset'), deletePreset: $('deletePreset')
      };

      var audioCtx = null;
      var audioPrimed = false;
      var activeNodes = [];
      var timers = [];
      var rafId = 0;
      var plan = null;
      var awaitingReveal = false;
      var root = document.body;

      var STORAGE_KEY = 'targetTrainer_settings_v1';
      var PRESET_KEY = 'targetTrainer_presets_v1';

      function readStore(key){
        try{
          var raw = localStorage.getItem(key);
          if(!raw) return null;
          var data = JSON.parse(raw);
          return (data && typeof data === 'object') ? data : null;
        }catch(e){ return null; }
      }

      function writeStore(key, value){
        try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){}
      }

      function loadSettings(){ return readStore(STORAGE_KEY) || {}; }
      function saveSettings(data){ writeStore(STORAGE_KEY, data || {}); }
      function loadPresetStore(){ return readStore(PRESET_KEY) || {}; }
      function savePresetStore(data){ writeStore(PRESET_KEY, data || {}); }

      async function ensureAudio(){
        if(!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        if(audioCtx.state !== 'running'){
          try{ await audioCtx.resume(); }catch(e){}
        }
        if(!audioPrimed){
          try{
            var buffer = audioCtx.createBuffer(1, audioCtx.sampleRate / 10, audioCtx.sampleRate);
            var channel = buffer.getChannelData(0);
            for(var i=0;i<channel.length;i++){ channel[i] = 0; }
            var src = audioCtx.createBufferSource();
            src.buffer = buffer;
            var gain = audioCtx.createGain();
            gain.gain.value = 0;
            src.connect(gain);
            gain.connect(audioCtx.destination);
            src.start();
            src.stop(audioCtx.currentTime + 0.05);
          }catch(e){}
          audioPrimed = true;
        }
        return audioCtx;
      }

      function cleanupNodes(){
        activeNodes.forEach(function(node){
          try{ if(typeof node.stop === 'function'){ node.stop(); } }catch(e){}
          try{ node.disconnect(); }catch(e){}
        });
        activeNodes.length = 0;
      }

      function beepNow(freq, len){
        if(!audioCtx || audioCtx.state !== 'running') return;
        var now = audioCtx.currentTime;
        var duration = Math.max(0.05, len);
        var osc = audioCtx.createOscillator();
        var gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.linearRampToValueAtTime(1, now + 0.01);
        gain.gain.linearRampToValueAtTime(0.0001, now + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + duration + 0.05);
        var remove = function(node){
          var idx = activeNodes.indexOf(node);
          if(idx !== -1){ activeNodes.splice(idx, 1); }
          try{ node.disconnect(); }catch(e){}
        };
        osc.addEventListener('ended', function(){ remove(osc); remove(gain); });
        activeNodes.push(osc, gain);
      }

      function clearTimers(){
        timers.forEach(function(id){ clearTimeout(id); });
        timers.length = 0;
      }

      function setStatus(txt){ if(els.status) els.status.textContent = txt; }

      function setBoardHidden(hidden){ if(els.targetBoard){ els.targetBoard.classList.toggle('targets-hidden', !!hidden); } }

      function updateMenuToggle(){
        if(!els.toggleMenu) return;
        var collapsed = root.classList.contains('menu-collapsed');
        els.toggleMenu.textContent = collapsed ? 'Show settings' : 'Hide settings';
        els.toggleMenu.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      }

      function setMenuCollapsed(collapsed){
        if(collapsed){ root.classList.add('menu-collapsed'); }
        else { root.classList.remove('menu-collapsed'); }
        updateMenuToggle();
        window.requestAnimationFrame(function(){ renderTargets(); });
      }

      function formatSeconds(value){ return value > 0 ? value.toFixed(2) + ' s' : '0.00 s'; }

      async function startRun(){
        await ensureAudio();
        stopRun(true);
        var minDelay = Math.max(0, parseFloat(els.delayMin.value));
        var maxDelay = Math.max(0, parseFloat(els.delayMax.value));
        if(isNaN(minDelay)) minDelay = 0;
        if(isNaN(maxDelay)) maxDelay = minDelay;
        if(maxDelay < minDelay){ var tmp = minDelay; minDelay = maxDelay; maxDelay = tmp; }
        var duration = Math.max(0, parseFloat(els.workDuration.value));
        if(isNaN(duration)){ duration = 0; }
        var startFrequency = Math.max(50, parseFloat(els.startFreq.value) || 0);
        var startLength = Math.max(0.05, parseFloat(els.startLen.value) || 0.1);
        var stopFrequency = Math.max(50, parseFloat(els.stopFreq.value) || 0);
        var stopLength = Math.max(0.05, parseFloat(els.stopLen.value) || 0.1);
        var delay = minDelay + Math.random() * (maxDelay - minDelay);
        var now = performance.now();
        plan = {
          startAt: now + delay * 1000,
          stopAt: now + (delay + duration) * 1000,
          delay: delay,
          duration: duration,
          startFreq: startFrequency,
          startLen: startLength,
          stopFreq: stopFrequency,
          stopLen: stopLength
        };
        if(els.hideTargets && els.hideTargets.checked){ awaitingReveal = true; setBoardHidden(true); }
        else { awaitingReveal = false; setBoardHidden(false); }
        setMenuCollapsed(true);
        els.startBtn.disabled = true;
        els.stopBtn.disabled = false;
        els.selectedDelay.textContent = delay.toFixed(2) + ' s';
        setStatus('Waiting for start beep…');

        timers.push(setTimeout(function(){
          ensureAudio().then(function(){
            beepNow(plan.startFreq, plan.startLen);
            if(awaitingReveal){ awaitingReveal = false; setBoardHidden(false); }
            setStatus('Run active');
          }).catch(function(){});
        }, delay * 1000));

        timers.push(setTimeout(function(){
          ensureAudio().then(function(){
            beepNow(plan.stopFreq, plan.stopLen);
            setStatus('Completed');
            var finalizeDelay = Math.max(0, plan.stopLen || 0) * 1000 + 120;
            timers.push(setTimeout(function(){ finalizeRun(); }, finalizeDelay));
          }).catch(function(){ finalizeRun(); });
        }, (delay + duration) * 1000));
      }

      function finalizeRun(){
        clearTimers();
        cleanupNodes();
        plan = null;
        els.startBtn.disabled = false;
        els.stopBtn.disabled = true;
        els.countStart.textContent = '—';
        els.countStop.textContent = '—';
        awaitingReveal = false;
        setBoardHidden(false);
      }

      function stopRun(skipStatus){
        clearTimers();
        cleanupNodes();
        if(plan && !skipStatus){ setStatus('Stopped'); }
        plan = null;
        els.startBtn.disabled = false;
        els.stopBtn.disabled = true;
        if(!skipStatus){ els.selectedDelay.textContent = '—'; }
        awaitingReveal = false;
        setBoardHidden(false);
      }

      function updateCounters(){
        if(plan){
          var now = performance.now();
          var toStart = Math.max(0, plan.startAt - now) / 1000;
          var toStop = Math.max(0, plan.stopAt - now) / 1000;
          els.countStart.textContent = toStart > 0 ? formatSeconds(toStart) : '0.00 s';
          els.countStop.textContent = toStop > 0 ? formatSeconds(toStop) : '0.00 s';
        } else {
          els.countStart.textContent = '—';
          els.countStop.textContent = '—';
        }
        rafId = window.requestAnimationFrame(updateCounters);
      }
      rafId = window.requestAnimationFrame(updateCounters);

      function randBetween(a,b){
        if(b < a){ var tmp = a; a = b; b = tmp; }
        return a + Math.random() * (b - a);
      }

      function shuffle(list){
        for(var i=list.length-1;i>0;i--){
          var j = Math.floor(Math.random() * (i + 1));
          var t = list[i];
          list[i] = list[j];
          list[j] = t;
        }
        return list;
      }

      function contrastColor(hex){
        if(!hex){ return '#111'; }
        var h = hex.replace('#','');
        if(h.length === 3){ h = h.split('').map(function(v){ return v + v; }).join(''); }
        if(h.length !== 6){ return '#111'; }
        var r = parseInt(h.slice(0,2), 16);
        var g = parseInt(h.slice(2,4), 16);
        var b = parseInt(h.slice(4,6), 16);
        if([r,g,b].some(function(v){ return isNaN(v); })){ return '#111'; }
        var luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
        return luminance > 0.55 ? '#111' : '#fff';
      }

      function renderTargets(){
        toggleSizeInputs();
        var board = els.targetBoard;
        if(!board) return;
        board.innerHTML = '';
        var count = Math.max(0, Math.floor(parseFloat(els.targetCount.value) || 0));
        if(count === 0){ return; }
        var shape = els.targetShape && els.targetShape.value === 'square' ? 'square' : 'circle';
        var color = els.targetColor && els.targetColor.value ? els.targetColor.value : '#d62828';
        var numbered = !!(els.targetNumbered && els.targetNumbered.checked);
        var random = !!(els.randomSizes && els.randomSizes.checked);
        var fixedSize = Math.max(10, parseFloat(els.targetSize.value) || 60);
        var minSize = Math.max(10, parseFloat(els.targetSizeMin.value) || 40);
        var maxSize = Math.max(10, parseFloat(els.targetSizeMax.value) || 100);
        if(maxSize < minSize){ var swap = minSize; minSize = maxSize; maxSize = swap; }
        var arrangement = els.targetLayout ? els.targetLayout.value : 'random';
        var labels = [];
        for(var n=1;n<=count;n++){ labels.push(n); }
        var gridLabels = arrangement === 'grid' ? shuffle(labels.slice()) : labels;
        var rect = board.getBoundingClientRect();
        var boardW = rect.width;
        var boardH = rect.height;
        if(!boardW || !boardH){
          var parentRect = board.parentElement ? board.parentElement.getBoundingClientRect() : null;
          if(parentRect && parentRect.width){ boardW = parentRect.width; boardH = parentRect.height || boardH; }
          if(!boardW || !boardH){ boardW = window.innerWidth || 800; boardH = window.innerHeight || 600; }
        }
        if(arrangement === 'grid'){
          renderGridTargets(board, count, shape, color, numbered, random, fixedSize, minSize, maxSize, boardW, boardH, gridLabels);
          return;
        }
        var placements = [];
        var attemptBase = count <= 10 ? 28 : (count <= 25 ? 20 : 14);
        for(var i=0;i<count;i++){
          var size = random ? randBetween(minSize, maxSize) : fixedSize;
          size = Math.max(10, size);
          var best = null;
          var attempts = attemptBase;
          for(var attempt=0; attempt<attempts; attempt++){
            var left = Math.random() * Math.max(0, boardW - size);
            var top = Math.random() * Math.max(0, boardH - size);
            left = Math.min(Math.max(0, left), Math.max(0, boardW - size));
            top = Math.min(Math.max(0, top), Math.max(0, boardH - size));
            var penalty = overlapPenalty(left, top, size, placements);
            if(!best || penalty < best.penalty){ best = { left:left, top:top, penalty:penalty }; }
            if(penalty === 0){ break; }
          }
          if(!best){ best = { left:0, top:0, penalty:0 }; }
          placements.push({ left:best.left, top:best.top, size:size });
          createTargetElement(board, labels[i], size, best.left, best.top, shape, color, numbered);
        }
      }

      function overlapPenalty(left, top, size, placements){
        var penalty = 0;
        var r = size / 2;
        var cx = left + r;
        var cy = top + r;
        for(var i=0;i<placements.length;i++){
          var other = placements[i];
          var or = other.size / 2;
          var ocx = other.left + or;
          var ocy = other.top + or;
          var dist = Math.hypot(cx - ocx, cy - ocy);
          var minDist = r + or;
          if(dist < minDist){ penalty += (minDist - dist); }
        }
        return penalty;
      }

      function renderGridTargets(board, count, shape, color, numbered, random, fixedSize, minSize, maxSize, boardW, boardH, labels){
        var aspect = boardW && boardH ? boardW / boardH : 1;
        var cols = Math.max(1, Math.ceil(Math.sqrt(count * (aspect || 1))));
        var rows = Math.max(1, Math.ceil(count / cols));
        var cellW = boardW / cols;
        var cellH = boardH / rows;
        var fitFactor = 0.82;
        for(var i=0;i<count;i++){
          var sizeCandidate = random ? randBetween(minSize, maxSize) : fixedSize;
          var maxFit = Math.max(10, Math.min(cellW, cellH) * fitFactor);
          var size = Math.max(10, Math.min(sizeCandidate, maxFit));
          var row = Math.floor(i / cols);
          var col = i % cols;
          var centerX = col * cellW + cellW / 2;
          var centerY = row * cellH + cellH / 2;
          var left = centerX - size / 2;
          var top = centerY - size / 2;
          left = Math.min(Math.max(0, left), Math.max(0, boardW - size));
          top = Math.min(Math.max(0, top), Math.max(0, boardH - size));
          var label = labels && labels[i] != null ? labels[i] : (i + 1);
          createTargetElement(board, label, size, left, top, shape, color, numbered);
        }
      }

      function createTargetElement(board, label, size, left, top, shape, color, numbered){
        var target = document.createElement('div');
        target.className = 'target ' + shape;
        target.style.width = size.toFixed(2) + 'px';
        target.style.height = size.toFixed(2) + 'px';
        target.style.left = left.toFixed(2) + 'px';
        target.style.top = top.toFixed(2) + 'px';
        target.style.backgroundColor = color;
        target.style.color = contrastColor(color);
        var fontSize = Math.max(12, size * 0.32);
        target.style.fontSize = fontSize.toFixed(2) + 'px';
        if(numbered){
          var span = document.createElement('span');
          span.textContent = String(label);
          target.appendChild(span);
        }
        board.appendChild(target);
      }

      function currentSettings(){
        return {
          delayMin: parseFloat(els.delayMin.value) || 0,
          delayMax: parseFloat(els.delayMax.value) || 0,
          workDuration: parseFloat(els.workDuration.value) || 0,
          startFreq: parseFloat(els.startFreq.value) || 0,
          startLen: parseFloat(els.startLen.value) || 0,
          stopFreq: parseFloat(els.stopFreq.value) || 0,
          stopLen: parseFloat(els.stopLen.value) || 0,
          targetCount: parseInt(els.targetCount.value, 10) || 0,
          targetShape: els.targetShape.value,
          targetColor: els.targetColor.value,
          targetLayout: els.targetLayout.value,
          targetNumbered: !!els.targetNumbered.checked,
          randomSizes: !!els.randomSizes.checked,
          hideTargets: !!els.hideTargets.checked,
          targetSize: parseFloat(els.targetSize.value) || 0,
          targetSizeMin: parseFloat(els.targetSizeMin.value) || 0,
          targetSizeMax: parseFloat(els.targetSizeMax.value) || 0
        };
      }

      function applySettings(state, opts){
        opts = opts || {};
        if(!state) state = {};
        function assignValue(el, val){ if(!el || val == null || val === '') return; el.value = val; }
        function assignNumber(el, val){ if(!el || val == null || val === '') return; el.value = val; }
        function assignCheckbox(el, val){ if(!el || val === undefined) return; el.checked = !!val; }

        assignNumber(els.delayMin, state.delayMin);
        assignNumber(els.delayMax, state.delayMax);
        assignNumber(els.workDuration, state.workDuration);
        assignNumber(els.startFreq, state.startFreq);
        assignNumber(els.startLen, state.startLen);
        assignNumber(els.stopFreq, state.stopFreq);
        assignNumber(els.stopLen, state.stopLen);
        assignNumber(els.targetCount, state.targetCount);
        assignValue(els.targetShape, state.targetShape);
        assignValue(els.targetColor, state.targetColor);
        assignValue(els.targetLayout, state.targetLayout);
        assignCheckbox(els.targetNumbered, state.targetNumbered);
        assignCheckbox(els.randomSizes, state.randomSizes);
        assignCheckbox(els.hideTargets, state.hideTargets);
        assignNumber(els.targetSize, state.targetSize);
        assignNumber(els.targetSizeMin, state.targetSizeMin);
        assignNumber(els.targetSizeMax, state.targetSizeMax);

        toggleSizeInputs();
        renderTargets();
        if(!opts.skipSave){ persist(); }
      }

      function persist(){ saveSettings(currentSettings()); }

      function fillPresetSelect(selected){
        if(!els.presetSelect) return;
        var presets = loadPresetStore();
        var opts = ['<option value="">Load preset…</option>'];
        Object.keys(presets).sort().forEach(function(name){
          opts.push('<option value="'+name+'">'+name+'</option>');
        });
        els.presetSelect.innerHTML = opts.join('');
        if(selected && presets[selected]){
          els.presetSelect.value = selected;
        } else {
          els.presetSelect.value = '';
        }
      }

      function toggleSizeInputs(){
        var random = els.randomSizes.checked;
        $('fixedSizeOptions').hidden = random;
        $('randomSizeOptions').hidden = !random;
      }

      function handleResize(){ renderTargets(); }

      els.startBtn.addEventListener('click', function(){ startRun(); });
      els.stopBtn.addEventListener('click', function(){ stopRun(false); });
      els.testStart.addEventListener('click', async function(){ await ensureAudio(); beepNow(Math.max(50, parseFloat(els.startFreq.value) || 0), Math.max(0.05, parseFloat(els.startLen.value) || 0.1)); });
      els.testStop.addEventListener('click', async function(){ await ensureAudio(); beepNow(Math.max(50, parseFloat(els.stopFreq.value) || 0), Math.max(0.05, parseFloat(els.stopLen.value) || 0.1)); });

      ['delayMin','delayMax','workDuration','startFreq','startLen','stopFreq','stopLen'].forEach(function(id){
        var input = $(id);
        if(!input) return;
        input.addEventListener('change', persist);
      });

      ['targetCount','targetShape','targetColor','targetSize','targetSizeMin','targetSizeMax','targetLayout'].forEach(function(id){
        var input = $(id);
        if(!input) return;
        input.addEventListener('input', function(){ renderTargets(); persist(); });
        input.addEventListener('change', function(){ renderTargets(); persist(); });
      });
      els.targetNumbered.addEventListener('change', function(){ renderTargets(); persist(); });
      els.randomSizes.addEventListener('change', function(){ toggleSizeInputs(); renderTargets(); persist(); });
      if(els.hideTargets){
        els.hideTargets.addEventListener('change', function(){
          if(plan){
            if(!els.hideTargets.checked){ awaitingReveal = false; setBoardHidden(false); }
            else if(awaitingReveal){ setBoardHidden(true); }
          } else {
            awaitingReveal = false; setBoardHidden(false);
          }
          persist();
        });
      }
      if(els.toggleMenu){
        els.toggleMenu.addEventListener('click', function(){
          var collapsed = root.classList.contains('menu-collapsed');
          setMenuCollapsed(!collapsed);
        });
      }

      fillPresetSelect();
      if(els.savePreset){
        els.savePreset.addEventListener('click', function(){
          var name = prompt('Preset name?');
          if(!name){ return; }
          name = name.trim();
          if(!name){ return; }
          var presets = loadPresetStore();
          if(presets[name] && !confirm('Overwrite preset "'+name+'"?')){ return; }
          presets[name] = currentSettings();
          savePresetStore(presets);
          fillPresetSelect(name);
        });
      }
      if(els.deletePreset){
        els.deletePreset.addEventListener('click', function(){
          var name = els.presetSelect ? els.presetSelect.value : '';
          if(!name){ alert('Select a preset to delete.'); return; }
          if(!confirm('Delete preset "'+name+'"?')) return;
          var presets = loadPresetStore();
          if(presets && presets[name]){ delete presets[name]; savePresetStore(presets); }
          fillPresetSelect();
        });
      }
      if(els.presetSelect){
        els.presetSelect.addEventListener('change', function(e){
          var name = e.target.value;
          if(!name) return;
          var presets = loadPresetStore();
          if(!presets[name]) return;
          applySettings(presets[name]);
        });
      }

      window.addEventListener('resize', handleResize);
      document.addEventListener('keydown', function(e){
        if(e.code === 'Space'){
          e.preventDefault();
          if(plan){ stopRun(false); }
          else { startRun(); }
        }
      });
      window.addEventListener('pointerdown', function(){ ensureAudio(); }, { once: true });

      var initialSettings = loadSettings();
      if(initialSettings && Object.keys(initialSettings).length){
        applySettings(initialSettings, { skipSave: true });
      } else {
        toggleSizeInputs();
        renderTargets();
        persist();
      }

      setBoardHidden(false);
      updateMenuToggle();
      window.requestAnimationFrame(function(){ renderTargets(); });
    })();
  </script>
</body>
</html>
